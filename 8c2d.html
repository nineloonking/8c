<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>現在四柱八字</title>
<style>
body {
    text-align: center;
    font-family: sans-serif;
}
.inputs {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;
}
.inputs input, .inputs select {
    margin: 5px 0;
    width: 80%;
    max-width: 300px;
}
table {
    margin: auto;
    border-collapse: collapse;
}
td {
    padding: 8px;
    border: 1px solid #ddd;
}
</style>
</head>

<body>

<div class="inputs">
	<input type="date" id="mydate" onchange="datechanged()" >
	<input type="time" id="mytime" onchange="datechanged()" >
	<select id="timezone" onchange="datechanged()">
		<option value="8" selected>香港 (UTC+8)</option>
		<option value="0">UTC</option>
		<option value="9">日本 (UTC+9)</option>
		<option value="7">泰國 (UTC+7)</option>
		<option value="1">UTC+1</option>
		<option value="-5">美國東部 (UTC-5)</option>
	</select>
</div>			
<div id="here"></div>

<script>  

var datelist = [
'2026-01-05T08:23:00Z',
'2026-01-20T01:45:00Z',
'2026-02-03T20:02:00Z',
'2026-02-18T15:52:00Z',
'2026-03-05T13:59:00Z',
'2026-03-20T14:46:00Z',
'2026-04-04T18:40:00Z',
'2026-04-20T01:39:00Z',
'2026-05-05T11:49:00Z',
'2026-05-21T00:37:00Z',
'2026-06-05T16:17:00Z',
'2026-06-21T09:59:00Z',
'2026-07-07T03:32:00Z',
'2026-07-22T21:01:00Z',
'2026-08-07T13:13:00Z',
'2026-08-23T03:46:00Z',
'2026-09-07T15:58:00Z',
'2026-09-23T01:24:00Z',
'2026-10-08T07:40:00Z',
'2026-10-23T10:47:00Z',
'2026-11-07T10:49:00Z',
'2026-11-22T08:27:00Z',
'2026-12-07T03:52:00Z',
'2026-12-21T21:58:00Z'
];
  
var workingdates = datelist;

const colorMap = {
            '甲': 'green', '乙': 'green', '寅': 'green', '卯': 'green',
            '丙': 'red', '丁': 'red', '巳': 'red', '午': 'red',
            '戊': 'khaki', '己': 'khaki', '丑': 'khaki', '辰': 'khaki', '未': 'khaki', '戌': 'khaki',
            '庚': 'gray', '辛': 'gray', '申': 'gray', '酉': 'gray',
            '壬': 'black', '癸': 'black', '子': 'black', '亥': 'black'
        };

function getinrange(number,range){

      while (number > range){number = number - range}

      while (number <= 0.0){number = number+range}            

        return number;

}

function finddifference(StartDate,EndDate)
{        
let enddatetemp = new Date(EndDate);

const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
enddatetemp.setHours(0, 0, 0); StartDate.setHours(0, 0, 0);
const diffDays = Math.round(Math.abs((enddatetemp - StartDate) / oneDay));

return diffDays
					
			
} //Function FindDifference ends here

function findSurroundingDates(dateArray, targetDate) {
  const target = new Date(targetDate).getTime();

  let low = 0;
  let high = dateArray.length - 1;

  // Edge cases
  if (target < new Date(dateArray[0]).getTime()) {
    return { beforeIndex: null, afterIndex: 0 };
  }
  if (target > new Date(dateArray[high]).getTime()) {
    return { beforeIndex: high, afterIndex: null };
  }

  // Binary search
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const midTime = new Date(dateArray[mid]).getTime();

    if (midTime === target) {
      return { beforeIndex: mid, afterIndex: mid }; // Exact match
    } else if (midTime < target) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  // At this point, high < low. The target is between dateArray[high] and dateArray[low]
  return { beforeIndex: high, afterIndex: low };
}

function datechanged(){
	
	
	
	
if (true) {
	
	let dateInput = document.getElementById('mydate').value;
	let timeInput = document.getElementById('mytime').value || '00:00';
	if (!dateInput) return;

	let [yearStr, monthStr, dayStr] = dateInput.split('-');
	let year = parseInt(yearStr);
	let month = parseInt(monthStr) - 1;
	let day = parseInt(dayStr);
	let [hourStr, minStr] = timeInput.split(':');
	let hours = parseInt(hourStr);
	let minutes = parseInt(minStr);

	let offset = parseFloat(document.getElementById('timezone').value) || 8;

	// UTC timestamp for solar terms
	let utcTimestamp = Date.UTC(year, month, day, hours, minutes, 0) - (offset * 3600 * 1000);
	let utcDate = new Date(utcTimestamp);

	// For day pillar and others, use the local date components
	let comparedate = new Date(); comparedate.setFullYear(1); comparedate.setDate(1);comparedate.setMonth(0); 
	let dateafteradjustment = new Date(Date.UTC(year, month, day, 0, 0, 0));
	let datediff = finddifference(comparedate, dateafteradjustment);

	if (year != 2026) {
	  here.innerHTML = '僅適用於2026年';
	  return;
	}
	
	//DayPillar Calculations Here
	daystem = getinrange((datediff % 10) + 6,10);
	daybranch = getinrange((datediff % 12) +4,12);		
					
	//Solar Term and Solar Month start both here
		
	let surroundingindex = findSurroundingDates(workingdates, utcDate.toISOString() );
	var previoussolartermindex = surroundingindex.beforeIndex;
	if (previoussolartermindex === null) {
	  previoussolartermindex = -1;
	}
		

		
	// Year calculation
	var yearstem = ((year - 3) % 10) || 10;
	var yearbranch = ((year - 3) % 12) || 12;
		
	// Adjust year if before Li Chun
	if (previoussolartermindex < 2) {
	  yearstem = getinrange(yearstem - 1, 10);
	  yearbranch = getinrange(yearbranch - 1, 12);
	}
	
	// Month calculation
	let last_jie_index;
	if (previoussolartermindex === -1) {
	  last_jie_index = 22;
	} else {
	  const is_zhong = previoussolartermindex % 2 === 1;
	  last_jie_index = is_zhong ? previoussolartermindex - 1 : previoussolartermindex;
	}
	var monthbranch = getinrange((last_jie_index / 2) + 2, 12);
	var solarmonth = getinrange(monthbranch - 2, 12);
		
	// Month stem
	var monthstem = getinrange(((yearstem % 5) * 2) + solarmonth, 10);
		
		
	//Hour Start here
	var hourbranch = (Math.floor((hours + 1) / 2) % 12) + 1;
		
	var starting_stem = ((daystem * 2 - 1) % 10) || 10;
	var hourstem = getinrange(starting_stem + hourbranch - 1, 10);
			
		
		
		
		var BranchesNamesshort = ["","子","丑" ,"寅","卯","辰","巳","午","未","申", "酉", "戌", "亥"]
		
		var stems = ["", "甲","乙","丙","丁","戊","己","庚","辛","壬","癸"];
		
		here.innerHTML = `
		<table>
		<tr><td>時</td><td>日</td><td>月</td><td>年</td></tr>
		<tr>
			<td><span style="color: ${colorMap[stems[hourstem]] || 'black'}">${stems[hourstem]}</span></td>
			<td><span style="color: ${colorMap[stems[daystem]] || 'black'}">${stems[daystem]}</span></td>
			<td><span style="color: ${colorMap[stems[monthstem]] || 'black'}">${stems[monthstem]}</span></td>
			<td><span style="color: ${colorMap[stems[yearstem]] || 'black'}">${stems[yearstem]}</span></td>
		</tr>
		<tr>
			<td><span style="color: ${colorMap[BranchesNamesshort[hourbranch]] || 'black'}">${BranchesNamesshort[hourbranch]}</span></td>
			<td><span style="color: ${colorMap[BranchesNamesshort[daybranch]] || 'black'}">${BranchesNamesshort[daybranch]}</span></td>
			<td><span style="color: ${colorMap[BranchesNamesshort[monthbranch]] || 'black'}">${BranchesNamesshort[monthbranch]}</span></td>
			<td><span style="color: ${colorMap[BranchesNamesshort[yearbranch]] || 'black'}">${BranchesNamesshort[yearbranch]}</span></td>
		</tr></table>`
	}//Closing Flow

}//Closing Date Changed

// Set initial date and time based on selected timezone
let nowUtcMs = Date.now();
let initialOffset = parseFloat(document.getElementById('timezone').value);
let nowInZone = new Date(nowUtcMs + (initialOffset * 3600 * 1000));
let isoDate = nowInZone.toISOString().split('T')[0];
let isoTime = nowInZone.toISOString().split('T')[1].split('.')[0].slice(0,5); // HH:MM
document.getElementById('mydate').value = isoDate;
document.getElementById('mytime').value = isoTime;

datechanged();

</script>



</body>
</html>
